/** 
  *easyFormGenerator 
  *Version 1.1.3 
  *Author : Erwan Datin (MacKentoch) 
  *Link: https://github.com/MacKentoch/easyFormGenerator 
  *License : MIT (2015) 
 **/ 
 ;(function(){
'use strict';
/// <reference path="../../../typings/lodash/lodash.d.ts"/>
/// <reference path="../../../typings/angularjs/angular.d.ts"/>
/**
 *  -----------------------------------------------------------------------
 *  application module of the step way version of easy form generator
 *  -----------------------------------------------------------------------
 *  
 *   
 *     - this version is production friendly -
 *
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/
;(function(){
  'use strict';


  angular
    .module('ngwfApp', [  
                          'ngwfApp.controllers',
                          'ngwfApp.services', 
                          'ngwfApp.filters',
                          'ngwfApp.directives',
                          'textAngular',
                          'textAngularSetup',
                          'ngAnimate',
                          'toaster',                      
                          'formly', 
                          'formlyBootstrap',
                          'ui.bootstrap',
                          'nya.bootstrap.select'
                        ]
            )
    .value('easyFormGenVersion', 'v1.0.7')
    .config(configfct);






    configfct.$inject = ['formlyConfigProvider'];
    function configfct(formlyConfigProvider){
      //////////////////////////////
      // CONFIG HERE (formly...)              
      /////////////////////////////
      formlyConfigProvider.setType(
        {
          name: 'richEditor',
          //wrapper: ['bootstrapLabel', 'bootstrapHasError'],
          template: '<text-angular name="{{id}}" class="richTextAngular" ng-model="model[options.key || index]"></text-angular>'
        }
      );

      formlyConfigProvider.setType(
        {
          name: 'blank',
          template: '<div></div>'
        }
      );


      var subTitleTemplate = '<div class="row"><div class=""><h4 class="text-center">{{options.templateOptions.placeholder}}<h4><hr/></div></div>';
      formlyConfigProvider.setType(
        {
          name: 'subTitle',
          template: subTitleTemplate
        }
      );

      var basicSelectTemplate =   ' <ol   class="nya-bs-select col-sm-12 col-xs-12 col-md-12 col-lg12" ' + 
                    '   ng-model="model[options.key || index]"  ' + 
                      '   id="{{id}}"  ' + 
                      '   disabled="options.templateOptions.options.length === 0"> ' + 
                      '   <li class="nya-bs-option" nya-bs-option="option in options.templateOptions.options"> ' + 
                      '     <a>{{option.name}}</a> ' + 
                      '   </li> ' + 
                      ' </ol>     ' ;

     formlyConfigProvider.setType(
        {
          name: 'basicSelect',
          template: basicSelectTemplate
        }
      );


     var groupedSelectTemplate =   '  <ol class="nya-bs-select col-sm-12 col-xs-12 col-md-12 col-lg12" ' +
                   '    ng-model="model[options.key || index]" ' +
                   '       data-live-search="true" ' +
                   '       disabled="options.templateOptions.options.length === 0">' +
                                 '       <li nya-bs-option="option in  options.templateOptions.options group by option.group"  ' +
                                 '       >' +
                                 '         <span class="dropdown-header">{{$group}}</span>' + 
                                 '         <a>' +
                                 '           <span>{{option.name}}</span>' +
                                 '           <span class="glyphicon glyphicon-ok check-mark"></span>' +
                                 '         </a>' +
                                 '       </li>' +
                                 '     </ol>';

     formlyConfigProvider.setType(
        {
          name: 'groupedSelect',
          template: groupedSelectTemplate
        }
      );

     ////////////////////////////
     // angular UI date picker
     ////////////////////////////
     // thx Kent C. Dodds

      var attributes = [
        'date-disabled',
        'custom-class',
        'show-weeks',
        'starting-day',
        'init-date',
        'min-mode',
        'max-mode',
        'format-day',
        'format-month',
        'format-year',
        'format-day-header',
        'format-day-title',
        'format-month-title',
        'year-range',
        'shortcut-propagation',
        'datepicker-popup',
        'show-button-bar',
        'current-text',
        'clear-text',
        'close-text',
        'close-on-date-selection',
        'datepicker-append-to-body'
      ];

      var bindings = [
        'datepicker-mode',
        'min-date',
        'max-date'
      ];

      var ngModelAttrs = {};

      angular.forEach(attributes, function(attr) {
        ngModelAttrs[camelize(attr)] = {attribute: attr};
      });

      angular.forEach(bindings, function(binding) {
        ngModelAttrs[camelize(binding)] = {bound: binding};
      });

    

      formlyConfigProvider.setType({
        name: 'datepicker',
        template: '<input  id="{{id}}" class="form-control" ng-click="open($event)" ng-model="model[options.key  || index]" is-open="to.isOpen" ng-click="to.isOpen = true" datepicker-options="to.datepickerOptions" />',
        wrapper: ['bootstrapLabel', 'bootstrapHasError'],
        controller: ['$scope', function($scope) {
           $scope.open = function($event) {
            $event.preventDefault();
            $event.stopPropagation();
            $scope.opened = true;
          };
         
         }],
        defaultOptions: {
          ngModelAttrs: ngModelAttrs,
          templateOptions: {
            addonLeft: {
              class: 'glyphicon glyphicon-calendar',
              onClick: function(options, scope) {
                options.templateOptions.isOpen = !options.templateOptions.isOpen;
              }
            },       
            onFocus: function($viewValue, $modelValue, scope) {
              scope.to.isOpen = !scope.to.isOpen;
            },
            datepickerOptions: {}
          }
        }
        
      });



      /**
       * wrappers to show validation errors
       * without having to rewrite formly types
       */
      formlyConfigProvider.setWrapper([
          {
            template: [
              '<div class="formly-template-wrapper form-group"',
              '     ng-class="{\'has-error\': options.validation.errorExistsAndShouldBeVisible}">',
              ' <formly-transclude></formly-transclude>',
              ' <div class="validation"',
              '       ng-if="options.validation.errorExistsAndShouldBeVisible"',
              '       ng-messages="options.formControl.$error">',
              '   <div ng-messages-include="validation.html"></div>',
              '   <div ng-message="{{::name}}" ng-repeat="(name, message) in ::options.validation.messages">',
              '     {{message(options.formControl.$viewValue, options.formControl.$modelValue, this)}}',
              '   </div>',
              ' </div>',
              '</div>'
            ].join(' ')
          }
        ]);

      function camelize(string) {
        string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
          return chr ? chr.toUpperCase() : '';
        });
        // Ensure 1st char is always lowercase
        return string.replace(/^([A-Z])/, function(match, chr) {
          return chr ? chr.toLowerCase() : '';
        });
      } 

    }


})();

/**
 *  ------------------------------------------------------
 *  controllers container
 *  ------------------------------------------------------
 *
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/
(function () {
	'use strict';


	angular.module('ngwfApp.controllers', [	
																				'ngwfApp.controllers.ngwfMainController',
																				'ngwfApp.controllers.ngwfWfEditController',
																				'ngwfApp.controllers.ngwfWfEditMODALController'
																				]
								);

})(); 


/**
 *  ------------------------------------------------------
 *  module = "controller" main controller
 *  ------------------------------------------------------
 *
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

;(function () {
	'use strict';

	angular
		.module('ngwfApp.controllers.ngwfMainController', [])
		.controller('ngwfMainController', ngwfMainController);

		ngwfMainController.$inject = [];
		function ngwfMainController(){

		}

})(); 


/**
 *  ------------------------------------------------------
 *  module = "controller" edit controller
 *  ------------------------------------------------------
 *
 * Main controller :
 * 
 *  - configuration model : fields model database friendly
 *  - formlymodel : fields model bound to formly directive (not database freindly)
 *  - vm.model : data model (database friendly)
 *
 * if you want more details on how to save to data base :
 *
 * http://www.erwan-datin.com/tips/how-do-I-store-angular-formly-fields-model-into-database
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

(function () {
  'use strict';




  angular
    .module('ngwfApp.controllers.ngwfWfEditController', [])
    .controller('ngwfWfEditController', ngwfWfEditController);


    ngwfWfEditController.$inject = [
      '$scope', 
      'easyFormGenVersion',
      '$filter',
      '$anchorScroll',
      'toaster', 
      '$timeout',
      '$modal',
      '$log', 
      'formFieldManage',
      'wfFormsByIdServices',
      'controllerModalProxy',
    ];

    function ngwfWfEditController(
                                    $scope, 
                                    easyFormGenVersion,
                                    $filter,
                                    $anchorScroll,
                                    toaster,
                                    $timeout, 
                                    $modal,
                                    $log, 
                                    formFieldManage, 
                                    wfFormsByIdServices, 
                                    controllerModalProxy
                                    ){


      $scope.easyFormGeneratorVERSION = easyFormGenVersion;
      $scope.debug                    = initDebugModel();
      $scope.tab                      = initTabModel();
      //formly control
      $scope.vm                       = this;
      $scope.vm.model                 = {};
      $scope.vm.wfFormFields          = [];
      $scope.vm.wfFormFieldsOnlyNeededProperties = []; 
      $scope.vm.onSubmit              = onSubmit;
      //configuration model (contains array of lines which contains array of columns)
      $scope.configuration            = {};    
                               
      $scope.numberOfColumns          = 1;
      $scope.MaxNumberOfColumns       = 3;
      $scope.MinNumberOfColumns       = 1;
      $scope.columnTemplate           = initColumnTemplate();

      $scope.lineTemplate             = initLineTemplate();
      $scope.resetToZeroModel         = resetToZeroModel;
      $scope.countConfigurationModelLines = countConfigurationModelLines;
      $scope.setActiveLineNumber      = setActiveLineNumber;
      $scope.upThisLine               = upThisLine;
      $scope.downThisLine             = downThisLine;
      $scope.addNewline               = addNewline;
      $scope.removeThisLine           = removeThisLine;

      $scope.increaseNumberOfColumns  = increaseNumberOfColumns;
      $scope.decreaseNumberOfColumns  = decreaseNumberOfColumns;

      $scope.resetStepCounter         = resetStepCounter;
      $scope.nextConfigStep           = nextConfigStep;

      $scope.previousConfigStep       = previousConfigStep;
      $scope.stepReachable            = stepReachable;

      $scope.toggleAnimation = toggleAnimation;

      $scope.nyaSelect                = {};
      
      $scope.animationsEnabled        = true;
      //call modal to edit selected control
      $scope.showModalAddCtrlToColumn = showModalAddCtrlToColumn;

      
      //disabled here : to load list of saved formly fields from database
      $scope.loadExistingFormsList    = loadExistingFormsAsList();
      $scope.formlyList               = {};
      $scope.previewLoadedForm        = { fieldsModel:[] };
      $scope.configurationLoaded      = {};   
      $scope.previewExistingform      = previewExistingform;
      $scope.saveThisForm             = saveThisForm; //should save to database (commented here)


   


      



      //load formlyList on init
      loadExistingFormsAsList();

      formFieldManage.initConfigurationEditFromScratch($scope.configuration);

      controllerModalProxy.initNyaSelect($scope.nyaSelect);



      function initDebugModel(){
        return {
         showDebug : false,
         configurationModelNumberofLines : 1        
        };
      }

      function initTabModel(){
        return {
          editTab : {active : true},
          previewTab : {active : false}
        };
      }

      function previewExistingform(formlyform){
       var configlines = JSON.parse(formlyform.formlyField);
       //here to replace with $scope.configuration : initialise configuration with lines 
       $scope.configurationLoaded = {};
       formFieldManage.bindConfigurationLines($scope.configurationLoaded,configlines);
       formFieldManage.applyConfigurationToformlyModel($scope.configurationLoaded, $scope.previewLoadedForm.fieldsModel, $scope.vm.model);
       $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);
       $scope.previewLoadedForm.cancelButtonText = formlyform.cancelButtonText;
       $scope.previewLoadedForm.submitButtonText = formlyform.submitButtonText;
      }    

      function onSubmit() {
        toaster.pop({
            type: 'info',
            timeout:2000,
            title: 'should save data model if it were not a static example',
            body: 'data :' + $filter('json')($scope.vm.model, 4),                
            showCloseButton: true
        }); 
      }
      
      function initColumnTemplate(){
        return  {
          numColumn: -1,
          exist:true, 
          control: {
            type:'none',
            key: 'none',
            subtype: 'none',
            // templateOptions: {
            //                     label: 'none',
            //                     placeholder: 'none',
            //                     required: false,
            //                     description: 'Descriptive text'
            //                   }
          }                                         
        };
      }

      function initLineTemplate(){
        return {
          line:-1, 
          activeColumn : 1,
          columns: [
            {  
              numColumn: 1,
              exist:true, 
              control: {
                type:'none',
                key: 'none',
                // templateOptions: {
                //                     label: 'none',
                //                     placeholder: 'none',
                //                     required: false,
                //                     description: 'Descriptive text'
                //                   }
                }
              }
            ]
        };
      }

      function resetToZeroModel(){
        $scope.configuration.activeLine = 1;
        if ($scope.configuration.lines.length > 1) {
          $scope.configuration.lines.splice(1, $scope.configuration.lines.length - 2);
        }
        return $scope.countConfigurationModelLines();
      }

      function countConfigurationModelLines(){
        //information in debug model
        $scope.debug.configurationModelNumberofLines = $scope.configuration.lines.length;
        return $scope.configuration.lines.length;
      }      

      function setActiveLineNumber(lineNumber){
        if (lineNumber <= $scope.countConfigurationModelLines()) {
          $scope.configuration.activeLine = lineNumber;
        }
      } 

      function upThisLine(indexLine){    
        if (indexLine > -1) {
          if ($scope.configuration.lines[indexLine - 1]) {
            var currentLineObj = $scope.configuration.lines[indexLine];
            $scope.configuration.lines.splice(indexLine , 1);
            $scope.configuration.lines.splice((indexLine - 1), 0, currentLineObj);    
            //manage selected aciveLine
            $scope.configuration.activeLine = 1;
          }
        }
          //re-render formfield 
        formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model);
        $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);     
      }  

      function downThisLine(indexLine){
        if (indexLine > -1) {
          if ($scope.configuration.lines[indexLine + 1]) {
            var currentLineObj = $scope.configuration.lines[indexLine];
            $scope.configuration.lines.splice(indexLine , 1);
            $scope.configuration.lines.splice((indexLine + 1), 0, currentLineObj);  
            //manage selected aciveLine
            $scope.configuration.activeLine = 1;
          }
        }     
        //re-render formfield 
        formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model); 
        $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);   
      } 

      function addNewline(){
        $scope.configuration.lines.push(
          {
            line:-1, 
            activeColumn : 1,
            columns: [
                      {  
                        numColumn: 1,
                        exist:true, 
                        control: {
                                    type:'none',
                                    key: 'none',
                                    // templateOptions: {
                                    //                     label: 'none',
                                    //                     placeholder: 'none',
                                    //                     required: false,
                                    //                     description: 'Descriptive text'
                                    //                   }
                                  }
                        }
                      ]
            }
        );
          //re-render formfield 
        formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model);
        $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields); 
      }

      function removeThisLine(index){
        if (index > -1) {
          if ($scope.configuration.lines.length > 1) {
              //manage selected aciveLine
              if ($scope.configuration.activeLine === index + 1) {
                $scope.configuration.activeLine = 1;
              }
              $scope.configuration.lines.splice(index, 1);
          }else{
            $timeout(function(){
                toaster.pop({
                        type: 'warning',
                        title: 'Last line' ,
                        body: 'Can\'t delete the last line',                
                        showCloseButton: true
                  });
            }, 100); 
          }
        //re-render formfield 
        formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model);
        $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);
        }
      }

      function increaseNumberOfColumns(){
        if ($scope
              .configuration
              .lines[$scope.configuration.activeLine -1]
              .columns.length < $scope.MaxNumberOfColumns) {

          var newNumberOfColumns = $scope
                                      .configuration
                                      .lines[$scope.configuration.activeLine -1]
                                      .columns
                                      .push(
                                            {
                                              numColumn: -1,
                                              exist: true, 
                                              control: {
                                                          type:'none',
                                                          key: 'none'
                                                          // templateOptions: {
                                                          //                     label: 'none',
                                                          //                     placeholder: 'none',
                                                          //                     required: false,
                                                          //                     description: 'Descriptive text'
                                                          //                   }
                                                        }                                         
                                             }                                        
                                            );
          $scope
              .configuration
              .lines[$scope.configuration.activeLine -1]
              .columns[newNumberOfColumns - 1]
              .numColumn = newNumberOfColumns; 
          }
           //re-render formfield 
          formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model); 
          $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);
      }  

      function decreaseNumberOfColumns(){
        if ($scope
              .configuration
              .lines[$scope.configuration.activeLine -1]
              .columns.length > 1) {
          $scope.configuration
            .lines[$scope.configuration.activeLine -1]
            .columns
            .splice($scope.configuration.lines[$scope.configuration.activeLine -1].columns.length -1, 1);
        }
        //re-render formfield 
        formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model);  

        $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);  
      }  

      function resetStepCounter(){
        $scope.configuration.configStepCounter = 0;
      } 

      function nextConfigStep(){
        var configStepCounterMAX = $scope.configuration.listConfigStep.length -1;
        if ($scope.configuration.configStepCounter !== configStepCounterMAX) {
            $scope.configuration.configStepCounter ++;
        }    
        setTrueThisStepIndicator($scope.configuration.configStepCounter);
      }   

      function previousConfigStep(){
        if ($scope.configuration.configStepCounter !== 0) {
          $scope.configuration.configStepCounter --;
        }
        setTrueThisStepIndicator($scope.configuration.configStepCounter);
      }

      function stepReachable(indexStep){
        if (indexStep < $scope.configuration.configStepCounter) {
          return 'disabled';
        }else{
          return 'enabled';
        }
      } 

      function showModalAddCtrlToColumn(size, indexLine, numcolumn) {

        var modalInstance = $modal.open({
                                          animation: $scope.animationsEnabled,
                                          templateUrl: 'modalWfEdit.html', 
                                          controller: 'ngwfWfEditMODALController',
                                          size: 'lg',
                                          resolve: {
                                            nyaSelect: function () {
                                              return controllerModalProxy
                                                        .getNyASelectFromSelectedLineColumn($scope.nyaSelect, $scope.configuration,indexLine, numcolumn);
                                            }
                                          }
        });

        modalInstance.result.then(function (modalAddCtrlModel) {
            controllerModalProxy.bindConfigurationModelFromModalReturn(indexLine, numcolumn, modalAddCtrlModel, $scope.configuration);
            formFieldManage.applyConfigurationToformlyModel($scope.configuration, $scope.vm.wfFormFields, $scope.vm.model);
            
            $scope.vm.wfFormFieldsOnlyNeededProperties = angular.copy($scope.vm.wfFormFields);

        }, function () {
          //$log.info('Modal dismissed at: ' + new Date());
        });
      } 

      function toggleAnimation() {
        $scope.animationsEnabled = !$scope.animationsEnabled;
      }            




      /**
       * loadExistingFormsAsList :
       *  - LOAD from database (list of forms)
       */
      function loadExistingFormsAsList(){
        // $scope.formlyList = wfFormsByIdServices.query();
      }
      /**
       * saveThisForm 
       * - SAVE to database (current stringified configuration model === current form)
       */
      function saveThisForm(){
        if (typeof $scope.configuration.formName === 'undefined') {
        toaster.pop({
                type: 'warning',
                timeout:2000,
                title: 'Form name is undefined',
                body: 'Form has not been saved.',                
                showCloseButton: true
          });
          return false;
        }
        if ($scope.configuration.formName === '') {
        toaster.pop({
                type: 'warning',
                timeout:2000,
                title: 'Form name is required',
                body: 'Form has not been saved.',                
                showCloseButton: true
          });
          return false;
        }
        toaster.pop({
                type: 'wait',
                timeout:10000,
                title: 'Form is being saved',
                body: 'Wait.',                
                showCloseButton: true
        });
        var wfForm = new wfFormsByIdServices();
        var formSavingIsOK = true;

        wfForm.formName = $scope.configuration.formName;
        wfForm.submitButtonText = $scope.configuration.submitButtonText;
        wfForm.cancelButtonText = $scope.configuration.cancelButtonText;

        wfForm.formlyField = JSON.stringify($scope.configuration.lines); 

        //------------------------------------------------------------------------------------------------------
        // UNCOMMENT TO MAKE IT SAVE TO DB 
        // -> (assuming your service in wfFormsByIdServices is well configurered for your RESTfull server)
        //------------------------------------------------------------------------------------------------------
        // save to database here 
        // wfForm.$save()
        //             .then(function(res)  {    formSavingIsOK = true;    })
        //             .catch(function(req) { 
        //                                   toaster.clear();
        //                                   formSavingIsOK = false; 
        //                                   toaster.pop({
        //                                           type: 'error',
        //                                           timeout:2000,
        //                                           title: 'Error while saving form',
        //                                           body: 'Sorry, an Error occured while saving form.',                
        //                                           showCloseButton: true
        //                                     });
        //             })
        //             .finally(function()  { 
        //                                   if (formSavingIsOK === true) {
        //                                     toaster.clear();  
        //                                     toaster.pop({
        //                                             type: 'success',
        //                                             timeout:2000,
        //                                             title: 'Form is successfully saved',
        //                                             body: '',                
        //                                             showCloseButton: true
        //                                       });                                         
        //                                   }
        //              });

        toaster.clear();  
        toaster.pop({
                type: 'info',
                timeout:2000,
                title: 'Form would be saved if it were not a static example',
                body: '',                
                showCloseButton: true
          }); 
        return true;
      } 




      function resetAllIndicators(){
        for (var i = $scope.configuration.stepIndicators.length - 1; i >= 0; i--) {
          $scope.configuration.stepIndicators[i] = false;
        }
      }
      
      function setTrueThisStepIndicator(indexIndicator){
          resetAllIndicators();
          $scope.configuration.stepIndicators[indexIndicator] = true;    
      }





    }


})(); 
/**
 *  ------------------------------------------------------
 *  module = "controller" modal controller
 *  ------------------------------------------------------
 *
 * edit control modal controller
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

(function () {
  'use strict';


  angular
    .module('ngwfApp.controllers.ngwfWfEditMODALController', [])
    .controller('ngwfWfEditMODALController', ngwfWfEditMODALController);

    ngwfWfEditMODALController.$inject = [
      '$scope', 
      '$modalInstance',
      'nyaSelect',
      'toaster' ,
      '$timeout',
      'selectOptionManage',
      'controllerModalProxy',
    ];

    function ngwfWfEditMODALController( $scope, 
                                        $modalInstance, 
                                        nyaSelect, 
                                        toaster,
                                        $timeout,
                                        selectOptionManage,
                                        controllerModalProxy
                                      ){
      
      var initOptionModel = { rows:[] };

      $scope.radioRowCollection = initOptionModel;
      $scope.newOptionRadio     = {saisie: ''};

      $scope.addNewOptionRadio  = addNewOptionRadio;
      $scope.removeRadioRow     = removeRadioRow;
      $scope.upThisRadioRow     = upThisRadioRow;
      $scope.downThisRadioRow   = downThisRadioRow;

      $scope.basicSelectRowCollection = initOptionModel;
      $scope.newOptionBasicSelect     = {saisie: ''}; 
      $scope.addNewOptionBasicSelect  = addNewOptionBasicSelect;
      $scope.removeRow                = removeRow;
      $scope.upThisRow                = upThisRow;
      $scope.downThisRow              = downThisRow;

      $scope.groupedSelectRowCollection = initOptionModel;
      $scope.newOptionGroupedSelect     = {saisie: ''};
      $scope.GroupedSelectGroups        = { list:[] };
      $scope.newGroupGroupedSelect      = {saisie: ''};  
      $scope.groupSelectGroupClick      = {showList : false};
      $scope.showGroupListToChoose      = showGroupListToChoose;
      $scope.addNewGroupToGroupedSelect = addNewGroupToGroupedSelect;
      $scope.addNewOptionGroupedSelect  = addNewOptionGroupedSelect;
      $scope.removeGroupedSelectRow     = removeGroupedSelectRow;
      $scope.upThisGroupedSelectRow     = upThisGroupedSelectRow;
      $scope.downThisGroupedSelectRow   = downThisGroupedSelectRow;

      $scope.demodt         = {}; 
      $scope.today          = today;
      $scope.clear          = clear;
      $scope.open           = openfct;
      $scope.dateOptions    = dateOptionsInit(); 
      $scope.demodt.formats = ['dd-MMMM-yyyy', 'yyyy/MM/dd', 'dd.MM.yyyy', 'shortDate'];

      $scope.nyaSelect                  = nyaSelect ;
      $scope.nyaSelect.selectedControl  = $scope.nyaSelect.temporyConfig.selectedControl;
      $scope.selectThisControl          = selectThisControl;
      $scope.ok                         = okfct;
      $scope.cancel                     = cancelfct;



      //init today date
      today();
      //init nyaSelect model depending selected control
      initNyaSelectConformingSelectedControl();


    
    
      function addNewOptionRadio(){
        var result = selectOptionManage.addNewOptionRadio($scope.radioRowCollection, $scope.newOptionRadio.saisie);
        if (result.resultFlag === false) {
              toaster.pop({
                type: 'warning',
                timeout:2000,
                title: result.details,
                body: '\''+ $scope.newOptionRadio.saisie + '\'' + ' cannot be added.',                
                showCloseButton: true
          });
        }
        //reset input
        $scope.newOptionRadio = {saisie: ''};
      }

      function removeRadioRow(index) {
        var result = selectOptionManage.removeOption($scope.radioRowCollection, index);
        if (result.resultFlag === false) {
            toaster.pop({
              type: 'warning',
              timeout:2000,
              title: result.details,
              body: 'Delete was cancelled.',                
              showCloseButton: true
          });
        }      
      } 

      function upThisRadioRow(index){
        var result = selectOptionManage.upthisOption($scope.radioRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        }       
      }

      function downThisRadioRow(index){
        var result = selectOptionManage.downthisOption($scope.radioRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        }
      }

      function addNewOptionBasicSelect(){
        var result = selectOptionManage.addNewOptionBasicSelect($scope.basicSelectRowCollection, $scope.newOptionBasicSelect.saisie);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: '\''+ $scope.newOptionBasicSelect.saisie + '\'' + ' cannot be added.',                
            showCloseButton: true
          });
        }
        //reset input
        $scope.newOptionBasicSelect = {saisie: ''};
      }  

      function removeRow(index) {
        var result = selectOptionManage.removeOption($scope.basicSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Delete was cancelled.',                
            showCloseButton: true
          });
        }      
      }   

      function upThisRow(index){
        var result = selectOptionManage.upthisOption($scope.basicSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        }       
      }

      function downThisRow(index){
        var result = selectOptionManage.downthisOption($scope.basicSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        }
      }

      function showGroupListToChoose(){
        $scope.groupSelectGroupClick.showList = !$scope.groupSelectGroupClick.showList;
      }

      function addNewGroupToGroupedSelect(){
        if ($scope.newGroupGroupedSelect.saisie !== '') {
          for (var i = $scope.GroupedSelectGroups.list.length - 1; i >= 0; i--) {
            if ($scope.GroupedSelectGroups.list[i] === $scope.newGroupGroupedSelect.saisie) {
              toaster.pop({
                type: 'warning',
                timeout:2000,
                title: 'Group already exists',
                body: 'No group added.',                
                showCloseButton: true
              });          
            }
          }
          $scope.GroupedSelectGroups.list.push($scope.newGroupGroupedSelect.saisie);
        }else{
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: 'Not a valid group to add',
            body: 'No group added.',                
            showCloseButton: true
          });
        }
        $scope.newGroupGroupedSelect.saisie = '';
      } 

      function addNewOptionGroupedSelect(){
        var result = selectOptionManage.addNewOptionGroupedSelect($scope.groupedSelectRowCollection, $scope.newOptionGroupedSelect.saisie, '');
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: '\''+ $scope.newOptionGroupedSelect.saisie + '\'' + ' cannot be added.',                
            showCloseButton: true
          });
        }
        //bind nya : dont bind here $apply is not done fast enough
        //bindGroupedSelectToNya();
        //reset input
        $scope.newOptionGroupedSelect = {saisie: ''};
      }

      function removeGroupedSelectRow(index) {
        var result = selectOptionManage.removeOption($scope.groupedSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Delete was cancelled.',                
            showCloseButton: true
          });
        }   
      }        

      function upThisGroupedSelectRow(index){
        var result = selectOptionManage.upthisOption($scope.groupedSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        } 
      }

      function downThisGroupedSelectRow(index){
        var result = selectOptionManage.downthisOption($scope.groupedSelectRowCollection, index);
        if (result.resultFlag === false) {
          toaster.pop({
            type: 'warning',
            timeout:2000,
            title: result.details,
            body: 'Operation cancelled.',                
            showCloseButton: true
          });
        } 
      }

      function today() {
        $scope.demodt.dt = new Date();
      } 

      function clear() {
        $scope.demodt.dt = null;
      } 

      function openfct($event){
        $event.preventDefault();
        $event.stopPropagation();
        $scope.demodt.opened = true;
      }

      function dateOptionsInit(){
        return  {
          formatYear: 'yy',
          startingDay: 1,
          showWeeks: true,
          initDate: null
        };
      }

      function selectThisControl(controlName){
        $scope.nyaSelect.selectedControl = 'none';
        resetTemporyConfig();

        for (var i = $scope.nyaSelect.controls.length - 1; i >= 0; i--) {
          if ($scope.nyaSelect.controls[i].id === controlName) {
            $scope.nyaSelect.selectedControl = $scope.nyaSelect.controls[i].id;         
          }
        }

        if ($scope.nyaSelect.selectedControl === 'Date') {
          initDatePicker();
        }
      }  

      function okfct() {
        if ($scope.nyaSelect.selectedControl === 'BasicSelect') {
          bindBasicSelectToNya();
        }
        if ($scope.nyaSelect.selectedControl === 'GroupedSelect') {
          bindGroupedSelectToNya();
        }  
        if ($scope.nyaSelect.selectedControl === 'Radio') {
          bindRadioToNya();
        }  
        //save config to control
        controllerModalProxy.applyConfigToSelectedControl($scope.nyaSelect);
        //return current model to parent controller :
        $modalInstance.close($scope.nyaSelect);
      }

      function cancelfct() {
        $modalInstance.dismiss('cancel');
      }    







      function bindRadioFromNYA(){
        if ($scope.nyaSelect.temporyConfig.formlyOptions.length > 0) {
          for (var i = 0; i <= $scope.nyaSelect.temporyConfig.formlyOptions.length-1; i++){
            var newOption = {
                'option': $scope.nyaSelect.temporyConfig.formlyOptions[i].name,
                'order': i,
                'group': ''
            };
            $scope.radioRowCollection.rows.push(newOption);
          }    
        }
      }

      function bindRadioToNya(){
        var resetNyASelectOptions = [];
        $scope.nyaSelect.temporyConfig.formlyOptions = resetNyASelectOptions;
        if ($scope.radioRowCollection.rows.length > 0) {
          for (var i = 0; i <= $scope.radioRowCollection.rows.length - 1; i++){
                var newOption = {
                  'name': $scope.radioRowCollection.rows[i].option,
                  'value': i,
                  'group': ''
                };
                $scope.nyaSelect.temporyConfig.formlyOptions.push(newOption);   
            }       
       }
      }

      function bindBasicSelectFromNYA(){
        if ($scope.nyaSelect.temporyConfig.formlyOptions.length > 0) {
          for (var i = 0; i <= $scope.nyaSelect.temporyConfig.formlyOptions.length-1; i++){
            var newOption = {
              'option': $scope.nyaSelect.temporyConfig.formlyOptions[i].name,
              'order': i,
              'group': ''
            };
            $scope.basicSelectRowCollection.rows.push(newOption);
          }    
        }
      }

      function bindBasicSelectToNya(){
        var resetNyASelectOptions = [];
        $scope.nyaSelect.temporyConfig.formlyOptions = resetNyASelectOptions;
        if ($scope.basicSelectRowCollection.rows.length > 0) {
          for (var i = 0; i <= $scope.basicSelectRowCollection.rows.length - 1; i++){
            var newOption = {
              'name': $scope.basicSelectRowCollection.rows[i].option,
              'value': i,
              'group': ''
            };
            $scope.nyaSelect.temporyConfig.formlyOptions.push(newOption);
          }      
        }
      } 

      function bindGroupedSelectFromNYA(){
        if ($scope.nyaSelect.temporyConfig.formlyOptions.length > 0) {
          for (var i = 0; i <= $scope.nyaSelect.temporyConfig.formlyOptions.length-1; i++){
            var newOption = {
              'option': $scope.nyaSelect.temporyConfig.formlyOptions[i].name,
              'order': i,
              'group': $scope.nyaSelect.temporyConfig.formlyOptions[i].group
            };
            $scope.groupedSelectRowCollection.rows.push(newOption);            
          }
          //grouplist : thx to lodash it is easy
          var filteredgroup = _.uniq(_.pluck($scope.groupedSelectRowCollection.rows, 'group'));
          angular.copy(filteredgroup, $scope.GroupedSelectGroups.list); 
        }
      }

      function bindGroupedSelectToNya(){
        $scope.nyaSelect.temporyConfig.formlyOptions = [];
        for (var i = 0; i <= $scope.groupedSelectRowCollection.rows.length - 1; i++){
          var newOption = {
            'name': $scope.groupedSelectRowCollection.rows[i].option,
            'value': i,
            'group': $scope.groupedSelectRowCollection.rows[i].group
          };
          $scope.nyaSelect.temporyConfig.formlyOptions.push(newOption);  
        }
      } 

      function initDatePicker(){
        $scope.nyaSelect.temporyConfig.datepickerPopup = $scope.demodt.formats[0];  
      }    

      function initNyaSelectConformingSelectedControl(){
        //place nya-select to selection if not none :
        if (nyaSelect.selectedControl !== 'none') {
          for (var i = $scope.nyaSelect.controls.length - 1; i >= 0; i--) {
             if ($scope.nyaSelect.controls[i].id === nyaSelect.selectedControl) {
                $scope.modelNyaSelect = nyaSelect.controls[i];
             }
          }
          if ($scope.nyaSelect.selectedControl === 'BasicSelect') {
            bindBasicSelectFromNYA();
          }
          if ($scope.nyaSelect.selectedControl === 'GroupedSelect') {
            bindGroupedSelectFromNYA();
          } 
          if ($scope.nyaSelect.selectedControl === 'Radio') {
            bindRadioFromNYA();
          }    
        }
      }

      function resetTemporyConfig(){
        $scope.nyaSelect.temporyConfig = {
          formlyLabel: '', 
          formlyRequired: false, 
          formlyPlaceholder: '',
          formlyDesciption: '',
          formlyOptions: []
        };   
      }


    }


})(); 
/**
 *  ------------------------------------------------------
 *  directives container
 *  ------------------------------------------------------
 *
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/
;(function () {
	'use strict';
	
	angular
		.module('ngwfApp.directives', [	'ngwfApp.directives.ngwfStRatioDirective' ]);

})(); 



/**
 *  ------------------------------------------------------
 *  simple directive to set width style attribute in %
 *  ------------------------------------------------------
 *
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

;(function () {
	
	'use strict';

	angular
		.module('ngwfApp.directives.ngwfStRatioDirective', [])
		.directive('stRatio', stRatio);

		stRatio.$inject = [];
		function stRatio(){

			var directive = {
				link : linkfct
			};

			return directive;

			function linkfct(scope, element, attr){
				var ratio=+(attr.stRatio);
			  element.css('width',ratio+'%');
			}

		}

})(); 




/**
 *  ------------------------------------------------------
 *  filters container
 *  ------------------------------------------------------
 *
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

;(function () {
	'use strict';

	angular
		.module('ngwfApp.filters', []);

})(); 



/**
 *  ------------------------------------------------------
 *  service : controllerModalProxy
 *  ------------------------------------------------------
 *
 *  service dedicated to - edit control - (controller modal proxy)
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/
(function () {
	'use strict';


	angular
		.module('ngwfApp.services.ngwfEditCtrlControllerModalProxy', [])
		.factory('controllerModalProxy', controllerModalProxy);

		controllerModalProxy.$inject = [];
		function controllerModalProxy(){
			
			var service = {
				initNyaSelect : initNyaSelect,
				getNyASelectFromSelectedLineColumn: getNyASelectFromSelectedLineColumn,
				bindConfigurationModelFromModalReturn : bindConfigurationModelFromModalReturn,
				applyConfigToSelectedControl : applyConfigToSelectedControl,
				resetTemporyConfig : resetTemporyConfig
			};
			
			return service;


			function initNyaSelect(nyaSelectObj){
				return resetNyaSelect(nyaSelectObj);
	    }

	    function getNyASelectFromSelectedLineColumn(nyaSelectObj, configurationObj, indexLine, numcolumn){
	      resetNyaSelect(nyaSelectObj);
	      /**
	       * data send to modal controller                                           
	       */
	      
	      if (typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions != 'undefined') {

	        nyaSelectObj.temporyConfig.selectedControl 		= typeof configurationObj.lines[indexLine].columns[numcolumn].control.selectedControl 						!= 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.selectedControl : 'none';
	        nyaSelectObj.temporyConfig.formlyLabel 				= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.label 			!= 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.label : '';
	        nyaSelectObj.temporyConfig.formlyRequired 		= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.required 		!= 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.required : '';
	        nyaSelectObj.temporyConfig.formlyDesciption 	= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.description != 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.description : '';
	        nyaSelectObj.temporyConfig.formlyPlaceholder 	= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.placeholder != 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.placeholder : '';
	        nyaSelectObj.temporyConfig.formlyOptions 			= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.options 		!= 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.options : '';
					
					nyaSelectObj.temporyConfig.formlyExpressionProperties = typeof configurationObj.lines[indexLine].columns[numcolumn].control.formlyExpressionProperties 	!= 'undefined' ? angular.copy(configurationObj.lines[indexLine].columns[numcolumn].control.formlyExpressionProperties) : {};
					nyaSelectObj.temporyConfig.formlyValidators 	= typeof configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidators 										!= 'undefined' ? angular.copy(configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidators) : {};
					nyaSelectObj.temporyConfig.formlyValidation 	= typeof configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidation 										!= 'undefined' ? angular.copy(configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidation) : {};
					
					/**
					 * particular case : datepicker 
					 */
	        if (nyaSelectObj.temporyConfig.selectedControl === 'Date') {
	        	nyaSelectObj.temporyConfig.datepickerPopup 	= typeof configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.datepickerPopup != 'undefined' ? configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.datepickerPopup : '';
	        }
	      }
	      return nyaSelectObj;	    	
	    }

	    function bindConfigurationModelFromModalReturn(indexLine, numcolumn, modalAddCtrlModel, configurationObj){
					      
	      var extractedProps = returnControlFromAddCtrlModalModel(modalAddCtrlModel);
	      configurationObj.lines[indexLine].columns[numcolumn].control.selectedControl 		= extractedProps.selectedControl;
	      configurationObj.lines[indexLine].columns[numcolumn].control.type 							= extractedProps.formlyType;
	      configurationObj.lines[indexLine].columns[numcolumn].control.subtype 						= extractedProps.formlySubtype;
	      //reset templateOptions
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions 		= {
	                                                                                            label: '',
	                                                                                            required: false,
	                                                                                            description: '',
	                                                                                            placeholder: '',
	                                                                                            options: []
	                                                                                          };
	       //then bind templateOptions                                                                                   
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.label 			 = extractedProps.formlyLabel;
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.required 	 = extractedProps.formlyRequired;
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.description = extractedProps.formlyDesciption;
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.placeholder = extractedProps.formlyPlaceholder;
	      configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.options 		 = extractedProps.formlyOptions;

	      configurationObj.lines[indexLine].columns[numcolumn].control.formlyExpressionProperties = angular.copy(extractedProps.formlyExpressionProperties);
	      configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidators 					= angular.copy(extractedProps.formlyValidators);
	      configurationObj.lines[indexLine].columns[numcolumn].control.formlyValidation 					= angular.copy(extractedProps.formlyValidation);

		  	//////////////////////////////////////////
	      // add additionnal particular properties
	      //////////////////////////////////////////
	      //-> datepicker : datepickerPopup
	      if (configurationObj.lines[indexLine].columns[numcolumn].control.type === 'datepicker') {
	       	configurationObj.lines[indexLine].columns[numcolumn].control.templateOptions.datepickerPopup = extractedProps.datepickerPopup;
	      }	
	      /**
	       * unique key (set only first time) in this model is formly control type + Date.now();  
	       */
	      var newKey = configurationObj.lines[indexLine].columns[numcolumn].control.type + '-' + Date.now();

	      if (validKeyUniqueness(newKey, configurationObj) === true){
	        configurationObj.lines[indexLine].columns[numcolumn].control.key = newKey;
	      }else{
	      	/**
	      	 * 2nd attempt 
	      	 */
	        newKey = configurationObj.lines[indexLine].columns[numcolumn].control.type + '-' + Date.now();

	        if (validKeyUniqueness(newKey, configurationObj) === true){
	          configurationObj.lines[indexLine].columns[numcolumn].control.key = newKey;
	        }else{
	        	/**
	        	 * 2nd attempt 
	        	 */
	          newKey = configurationObj.lines[indexLine].columns[numcolumn].control.type + '-' + Date.now();
	        }
	      }                                                                     
	    	configurationObj.lines[indexLine].columns[numcolumn].control.edited = true;
	  	}

	  	function applyConfigToSelectedControl(nyaSelectObj){
		  	/**
		  	 * used in modal (edit control) 
		  	 */
		    for (var i = nyaSelectObj.controls.length - 1; i >= 0; i--) {
		      if (nyaSelectObj.controls[i].id === nyaSelectObj.selectedControl) {

		          nyaSelectObj.controls[i].formlyLabel 								= nyaSelectObj.temporyConfig.formlyLabel;
		          nyaSelectObj.controls[i].formlyRequired 						= nyaSelectObj.temporyConfig.formlyRequired;
		          nyaSelectObj.controls[i].formlyDesciption 					= nyaSelectObj.temporyConfig.formlyDesciption;
		          nyaSelectObj.controls[i].formlyPlaceholder 					= nyaSelectObj.temporyConfig.formlyPlaceholder;
		          nyaSelectObj.controls[i].formlyOptions 							= nyaSelectObj.temporyConfig.formlyOptions;

		          if (nyaSelectObj.controls[i].id ==='Date' ) {
		          	nyaSelectObj.controls[i].datepickerPopup 					= nyaSelectObj.temporyConfig.datepickerPopup;
		          }
		        
		       }
		    }
		  }

		  function resetTemporyConfig(){
		    return {
	              formlyLabel: '', 
	              formlyRequired: false, 
	              formlyPlaceholder: '',
	              formlyDesciption: '',
	              formlyOptions: []
	            }; 		  	
		  }



	    /**
	     * init object : return true (if not true, you may have problem^^)
	     */
		  function resetNyaSelect(nyaSelectObj){
		    var newNyaSelectObj = {

		                    controls : [
		                                {
		                                	id: 'empty',  
		                                	name: 'no control', 
		                                	subtitle: 'no control', 
		                                	group: 'Blank', 
		                                	formlyType: 'blank', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [] , 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
		                                	formlyValidation: {} 
		                                },

		                                {id: 'Header',  name: 'Header', subtitle: 'no control', group: 'Decoration', formlyType: 'header', formlySubtype: '', formlyLabel: '', formlyRequired: false, formlyDesciption: '', formlyOptions: [] , formlyExpressionProperties: {}, formlyValidators: {}, formlyValidation: {}},
		                                {id: 'Subtitle',  name: 'Subtitle', subtitle: 'no control', group: 'Decoration', formlyType: 'subTitle', formlySubtype: '', formlyLabel: '', formlyRequired: false, formlyDesciption: '', formlyOptions: [] , formlyExpressionProperties: {}, formlyValidators: {}, formlyValidation: {}},

		                                {
		                                	id: 'TextInput',  
		                                	name: 'Text input', 
		                                	subtitle: 'Text input', 
		                                	group: 'input', 
		                                	formlyType: 'input', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [] , 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
		                                	formlyValidation: {
						                                		          messages: {
																													            required: function(viewValue, modelValue, scope) {
																													              		//return a required validation message : 
																													              		//-> '<label as name> is required '
																													              		//-> or if not exists or empty just 'this field is required'
																													              		var defaultReturnMsg = 'this Text input field is required';
																													              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																													              		return returnMsg;
																													            		}
						                                												}
		                                										}
		                                },

		                                {
		                                	id: 'Password',  
		                               	 	name: 'Password', 
		                                	subtitle: 'Password', 
		                                	group: 'input', 
		                                	formlyType: 'input', 
		                                	formlySubtype: 'password', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [] , 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
	                                		formlyValidation: {
					                                		          messages: {
																												            required: function(viewValue, modelValue, scope) {
																												              		//return a required validation message : 
																												              		//-> '<label as name> is required '
																												              		//-> or if not exists or empty just 'this field is required'
																												              		var defaultReturnMsg = 'this Password field is required';
																												              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																												              		return returnMsg;
																												            		}
					                                												}
	                                										}
		                              },
		                                
		                                {
		                                	id 													: 'Email',  
		                                	name 												: 'Email', 
		                                	subtitle 										: 'Email', 
		                                	group 											: 'input', 
		                                	formlyType									: 'input', 
		                                	formlySubtype 							: 'email', 
		                                	formlyLabel 								: '', 
		                                	formlyRequired 							: false, 
		                                	formlyDesciption 						: '', 
		                                	formlyOptions 							: [], 
		                                	formlyExpressionProperties 	: {}, 

		                                	formlyValidators 						: {
																	                                		emailShape : {
																																			            		expression : function(viewValue, modelValue) {
																																			              		var value = modelValue || viewValue;
																																			              		return /^[a-z]+[a-z0-9._]+@[a-z]+\.[a-z.]{2,5}$/.test(value);
																																			            		},
																																			            		message: '$viewValue + \' is not a valid email\''
																																			          		}
																						                        },

		                                	formlyValidation: {
						                                		          messages: {
																													            required: function(viewValue, modelValue, scope) {
																													              		//return a required validation message : 
																													              		//-> '<label as name> is required '
																													              		//-> or if not exists or empty just 'this field is required'
																													              		
																													              		var defaultReturnMsg = 'this Email field is required';
																													              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																													              		//check if validation is really dued to require validation 
																													              		//and not another validation like emailShape validator
																													              		if (scope.to.required) return returnMsg;
																													            		}
						                                												}
		                                										}
		                                },
		                                
		                                {
		                                	id: 'Date',  
		                                	name: 'Date', 
		                                	subtitle: 'Date', 
		                                	group: 'input', 
		                                	formlyType: 'datepicker', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [], 
		                                	datepickerPopup: 'dd-MMMM-yyyy', 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
		                                	formlyValidation: {
						                                		          messages: {
																													            required: function(viewValue, modelValue, scope) {
																													              		//return a required validation message : 
																													              		//-> '<label as name> is required '
																													              		//-> or if not exists or empty just 'this field is required'
																													              		var defaultReturnMsg = 'this Date field is required';
																													              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																													              		return returnMsg;
																													            		}
						                                												}
		                                										}
		                                },

		                                {
		                                	id: 'Texarea', 
		                                	name: 'Textarea', 
		                                	subtitle: 'Textarea', 
		                                	group: 'Textarea', 
		                                	formlyType: 'textarea', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
		                                	formlyValidation: {
						                                		          messages: {
																													            required: function(viewValue, modelValue, scope) {
																													              		//return a required validation message : 
																													              		//-> '<label as name> is required '
																													              		//-> or if not exists or empty just 'this field is required'
																													              		var defaultReturnMsg = 'this Textarea field is required';
																													              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																													              		return returnMsg;
																													            		}
						                                												}
		                                										}
		                                },

		                                {
		                                	id: 'RichTextEditor', 
		                                	name: 'RichTextEditor', 
		                                	subtitle: 'RichTextEditor', 
		                                	group: 'Textarea', 
		                                	formlyType: 'richEditor', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		   
		                                	formlyValidators 						: {},

		                                	formlyValidation: {
						                                		          messages: {
																													            required: function(viewValue, modelValue, scope) {
																													              		//return a required validation message : 
																													              		//-> '<label as name> is required '
																													              		//-> or if not exists or empty just 'this field is required'
																													              		var defaultReturnMsg = 'this RichTextEditor field is required';
																													              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																													              		return returnMsg;
																													            		}
						                                												}
		                                										}
		                                },

		                                {
		                                	id: 'Radio', 
		                                	name: 'Radio', 
		                                	subtitle: 'Radio', 
		                                	options: [], 
		                                	group: 'Radio', 
		                                	formlyType: 'radio', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '' , 
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
	                                		formlyValidation: {
					                                		          messages: {
																												            required: function(viewValue, modelValue, scope) {
																												              		//return a required validation message : 
																												              		//-> '<label as name> is required '
																												              		//-> or if not exists or empty just 'this field is required'
																												              		var defaultReturnMsg = 'this Password field is required';
																												              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																												              		return returnMsg;
																												            		}
					                                												}
	                                										}
		                                },

		                                {
		                                	id: 'Checkbox', 
		                                	name: 'Checkbox', 
		                                	subtitle: 'Checkbox', 
		                                	group: 'Checkbox', 
		                                	formlyType: 'checkbox', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
	                                		formlyValidation: {
					                                		          messages: {
																												            required: function(viewValue, modelValue, scope) {
																												              		//return a required validation message : 
																												              		//-> '<label as name> is required '
																												              		//-> or if not exists or empty just 'this field is required'
																												              		var defaultReturnMsg = 'this Checkbox field is required';
																												              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																												              		return returnMsg;
																												            		}
					                                												}
	                                										}
		                                },

		                                {
		                                	id: 'BasicSelect', 
		                                	name: 'Basic select', 
		                                	subtitle: 'Basic select',
		                                	options: [], 
		                                	group: 'Select', 
		                                	formlyType: 'basicSelect', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '', 
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
	                                		formlyValidation: {
					                                		          messages: {
																												            required: function(viewValue, modelValue, scope) {
																												              		//return a required validation message : 
																												              		//-> '<label as name> is required '
																												              		//-> or if not exists or empty just 'this field is required'
																												              		var defaultReturnMsg = 'this Basic select field is required';
																												              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																												              		return returnMsg;
																												            		}
					                                												}
	                                										}
		                                },

		                                {
		                                	id: 'GroupedSelect', 
		                                	name: 'Grouped Select', 
		                                	subtitle: 'Grouped Select',
		                                	options: [], 
		                                	group: 'Select', 
		                                	formlyType: 'groupedSelect', 
		                                	formlySubtype: '', 
		                                	formlyLabel: '', 
		                                	formlyRequired: false, 
		                                	formlyDesciption: '',
		                                	formlyOptions: [], 
		                                	formlyExpressionProperties: {}, 
		                                	formlyValidators: {}, 
	                                		formlyValidation: {
					                                		          messages: {
																												            required: function(viewValue, modelValue, scope) {
																												              		//return a required validation message : 
																												              		//-> '<label as name> is required '
																												              		//-> or if not exists or empty just 'this field is required'
																												              		var defaultReturnMsg = 'this Grouped Select field is required';
																												              		var returnMsg = (typeof scope.to.label !== 'undefined') ? ((scope.to.label !== '') ? scope.to.label + ' is required' : defaultReturnMsg) : defaultReturnMsg;
																												              		return returnMsg;
																												            		}
					                                												}
	                                										}
		                                }
		                              ],

		                      selectedControl : 'none' ,
		                      temporyConfig : {
		                                        selectedControl: 'none',
		                                        formlyLabel: 'label', 
		                                        formlyRequired: false, 
		                                        formlyDesciption: '',
		                                        formlyPlaceholder: '',
		                                        formlyOptions : [],
																	          //expressions/validation fields
																	          formlyExpressionProperties: {},
																	          formlyValidators: {},
																	          formlyValidation: {}                                        
		                                      } 

		    };

		    //reset
		  	angular.copy(newNyaSelectObj, nyaSelectObj);
		    return true;
		  }
		  /**
		   * data passed back to parent controller 
		   * after control being finsihed editing in modal
		   */
		  function returnControlFromAddCtrlModalModel(CtrlModalModel){

		    var modelToReturn = {
		          selectedControl:'none', 
		          formlyType : 'none',
		          formlySubtype: 'none',
		          formlyLabel: '',
		          formlyRequired : false,
		          formlyDesciption: '',
		          formlyPlaceholder: '',
		          formlyOptions: [],
		          //validation fields
		          formlyExpressionProperties: {},
		          formlyValidators: {},
		          formlyValidation: {}
		    };


		    for (var i = CtrlModalModel.controls.length - 1; i >= 0; i--) {
		      if (CtrlModalModel.selectedControl === CtrlModalModel.controls[i].id) {
		        modelToReturn.selectedControl 		= CtrlModalModel.selectedControl;
		        modelToReturn.formlyType 					= CtrlModalModel.controls[i].formlyType;
		        modelToReturn.formlySubtype 			= CtrlModalModel.controls[i].formlySubtype;
		        modelToReturn.formlyLabel 				= CtrlModalModel.controls[i].formlyLabel;
		        modelToReturn.formlyRequired 			= CtrlModalModel.controls[i].formlyRequired;
		        modelToReturn.formlyDesciption 		= CtrlModalModel.controls[i].formlyDesciption;
		        modelToReturn.formlyPlaceholder 	= CtrlModalModel.controls[i].formlyPlaceholder;
		        modelToReturn.formlyOptions 			= CtrlModalModel.controls[i].formlyOptions;

		        modelToReturn.formlyExpressionProperties 	= angular.copy(CtrlModalModel.controls[i].formlyExpressionProperties);
		        modelToReturn.formlyValidators 						= angular.copy(CtrlModalModel.controls[i].formlyValidators);
		        modelToReturn.formlyValidation 						= angular.copy(CtrlModalModel.controls[i].formlyValidation);

		        //particular properties 
		        //datetpicker format
		        if (CtrlModalModel.controls[i].formlyType === 'datepicker') {
					modelToReturn.datepickerPopup 							= CtrlModalModel.controls[i].datepickerPopup;   
					  	
		        }
		      }
		    }
		    return modelToReturn;
		  }
			/**
			 * validKeyUniqueness
			 * to be sure the "keys" are unique (in same formly field model)
			 */
		  function validKeyUniqueness(thisKey, configurationObj){
		    var isUnique = true;
		    //each lines
		    for (var i = configurationObj.lines.length - 1; i >= 0; i--) {
		      //each columns
		      for (var j = configurationObj.lines[i].columns.length - 1; j >= 0; j--) {
		        if (configurationObj.lines[i].columns[j].control.key === thisKey) {
		          isUnique = false;
		        }
		          
		      }
		      
		    }

		    return isUnique;  
		  }  

		}

})(); 

/**
 *  ------------------------------------------------------
 *  service : formFieldManage
 *  ------------------------------------------------------
 *
 *         MOST IMPORTANT service to manage formly field model 
 *  (the presentation model and the back model or configuration model)
 * 
 *
 *  - "formlyModel" is the model exposed to view or html "fields model" (= an array of objects)
 *    This model is the one you can see in all well documented examples here : http://angular-formly.com
 *    -> in your view or html : <formly-form model="dataModel" fields="formlyModel">
 *
 *  - "configurationModel" is the model on which editing a form will work
 *    before applying results to "formlyModel"
 *
 *
 * NOTE : if you save a form to database, you will save "configurationModel" rather than "formlyModel".
 *        Why? : 
 *          since as you plan to create a form generator you can't create a finite model
 *          since you may want to be able to save the generated form even if it is not a finite model
 *          since "formlyModel" objects will be populated with a lot of properties you don't need to store contrary to "configurationModel" which contains only what you need
 *          since "formlyModel" can't be JSON.stringify when you want to use advanced layout (1 column/2/3 columns template?)
 *          since it is better approach to use a backgroundModel (async operation ...) that is bind to presentation model only when it is fully ready or filled.
 *
 *
 * NOTE : 
 * - if you want to manage more columns templates (right now only manage up to 3 columns), just inspire from existing code
 * - if you want to extend easy form generator, be sure to be a minimum comfortable with "angular formly": http://angular-formly.com
 * 
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/
angular
  .module('ngwfApp.services.formFieldManage', [])
  .factory('formFieldManage', [ 
    function(){

    var Service = {};

    /**
     * At initial state : configuration model will contain 1 line, since :
     *    -> it is non sense to create a form without a single line (no line = no form at all)
     *    -> so it is non sense to force user to add a first line
     * 
     *  PLEASE NOTE columns array contains objects that look like formly fields one
     */
    Service.initConfigurationEditFromScratch =  function(configurationModel){
      var configurationModelInit = {

        activeLine: 1,   

        listConfigStep: [
                          'init',
                          'first',
                          'second',
                          'third'
                        ],
                      
        stepIndicators:  [
                            true,
                            false,
                            false,
                            false
                          ], 
        configStepCounter : 0, 
        submitButtonText  : 'submit',
        cancelButtonText  : 'cancel',

        lines: [
                {
                    line:1,                                       
                    activeColumn : 1,
                    columns: [
                              {  
                                numColumn: 1,
                                exist:true, 
                                control: {
                                            type:'none',
                                            key: 'none',
                                            // templateOptions: {
                                            //                     label: 'none',
                                            //                     placeholder: 'none',
                                            //                     required: false,
                                            //                     description: 'Descriptive text'
                                            //                   }
                                          }
                                }
                              ]
                 }                                 
            ]
      };
      
      angular.copy(configurationModelInit, configurationModel);                   
    };
    /**
     * Get an configuration empty (no init line) then empty it with lines array provided in param
     * @param   object - configurationModel   [configuration model]
     * @param   array -  lines                [an array : lines to apply to an empty configuration model]
     * @param   bool -   addStepWayProperties [description]
     * @return {object message}               [give details on how it happened to caller]
     */
    Service.bindConfigurationLines = function(configurationModel, lines){
              
      if( Object.prototype.toString.call(lines) === '[object Array]' ) {
        var configurationModelResult = {
                                  activeLine: 1,   
                                  listConfigStep: [
                                                    'init',
                                                    'first',
                                                    'second',
                                                    'third'
                                                  ],
                                  stepIndicators:  [
                                                      true,
                                                      false,
                                                      false,
                                                      false
                                                    ], 
                                  configStepCounter: 0, 
                                  submitButtonText : 'submit',
                                  cancelButtonText: 'cancel',
                                  lines: []
                                };

        configurationModelResult.lines = [].concat(lines);  
        angular.copy(configurationModelResult, configurationModel);                                         

        return getMessageObject('configuration model is bound','lines are bound to configuration model.');
      }else{
        return getErrorObject('lines is not an array', 'Checks lines type, it is not an array.');
      }
    };
    /**
     * applyConfigurationToformlyModel : 
     *  - bind configuration model into formly field model
     *  - reset dataModel (formlyfield may have changed so previous dataModel would be false)
     * @param  configurationModel 
     * @param  formlyModel        
     * @param  formlyDataModel    
     */
    Service.applyConfigurationToformlyModel = function(configurationModel, formlyModel, formlyDataModel){
      resetFormlyModel(formlyModel);
      resetDataModel(formlyDataModel);
      /**
       * manage header here line0 
       */
      var lineNumber = configurationModel.lines.length;
      for (var i = 0; i < lineNumber; i++) {
          //1 column line control
          if (configurationModel.lines[i].columns.length === 1) {
            //test if template control = header
            if (configurationModel.lines[i].columns[0].control.type === 'header') {
              AddOneColumnHeader(formlyModel, configurationModel, i);
            }else{
              AddOneColumnControl(formlyModel, configurationModel, i);  
            }          
          }
          if (configurationModel.lines[i].columns.length === 2) {
            AddTwoColumnControl(formlyModel, configurationModel,i);
          }

          if (configurationModel.lines[i].columns.length === 3) {
            AddThreeColumnControl(formlyModel, configurationModel,i);
          }
      }

    };

    return Service;



    function resetFormlyModel(formlyModel){
      var resetformly = [];
      angular.copy(resetformly, formlyModel);
    }

    function AddOneColumnHeader(formlyModel, configurationModel,lineIndex){
      /**
       * text header is stored in "description" in templateOtion model 
       */
      var headerTemplateCol0 = '<div class="row"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control) + '<h2></div></div><hr/>';

      formlyModel.push(
                        {
                          template: typeof configurationModel.lines[lineIndex].columns[0].control.type !== 'undefined' ? (configurationModel.lines[lineIndex].columns[0].control.type === 'header' ? headerTemplateCol0 : '<div></div>') : '<div></div>'
                        }
                      );
    }


    function AddDatepickerPopupProperty(fieldToPush, configurationModel,lineIndex){

        fieldToPush.templateOptions.datepickerPopup = extractTemplateOptionDatepickerPopup(configurationModel.lines[lineIndex].columns[0].control);
    }

    function AddOneColumnControl(formlyModel, configurationModel,lineIndex){

        var fieldToPush =                       {
                            className: 'col-xs-12',
                            type: typeof configurationModel.lines[lineIndex].columns[0].control.type !== 'undefined' ? (configurationModel.lines[lineIndex].columns[0].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[0].control.type): 'blank',
                            key: typeof configurationModel.lines[lineIndex].columns[0].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[0].control.key : 'blank' + Date.now(),
                            templateOptions: {
                              type                  : extractTemplateOptionType(configurationModel.lines[lineIndex].columns[0].control),
                              label                 : extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[0].control),
                              required              : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[0].control),
                              placeholder           : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[0].control),
                              description           : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control),
                              options               : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[0].control)
                            },
                            expressionProperties  : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[0].control),
                            validators            : extractFormlyValidators(configurationModel.lines[lineIndex].columns[0].control),
                            validation            : extractFormlyValidation(configurationModel.lines[lineIndex].columns[0].control)
                          };
        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[0].control.type === 'datepicker') {
          AddDatepickerPopupProperty(fieldToPush, configurationModel,lineIndex);
        }     

        formlyModel.push( 
                          fieldToPush
                        );
    }

    function AddTwoColumnControl(formlyModel, configurationModel,lineIndex){


        //text header is stored in "description" in templateOtion model
        var headerTemplateCol0 =  {
                                    className: 'col-xs-6',
                                    template : '<div class="row"><div class=""><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control) + '<h2><hr/></div></div>'
                                  };

        var headerTemplateCol1 =  {
                                    className: 'col-xs-6',
                                   template:'<div class="row"><div class=""><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[1].control) + '<h2><hr/></div></div>'
                                  };

      

        var controlCol0 =     {
                                  className: 'col-xs-6',
                                  type: typeof configurationModel.lines[lineIndex].columns[0].control.type !== 'undefined' ? (configurationModel.lines[lineIndex].columns[0].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[0].control.type): 'blank',
                                  key: typeof configurationModel.lines[lineIndex].columns[0].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[0].control.key : 'blank' + Date.now(),
                                  templateOptions: {
                                      type: extractTemplateOptionType(configurationModel.lines[lineIndex].columns[0].control),
                                      label: extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[0].control),
                                      required : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[0].control),
                                      placeholder : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[0].control),
                                      description : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control),
                                      options : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[0].control)
                                  },
                                      expressionProperties : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[0].control),
                                      validators : extractFormlyValidators(configurationModel.lines[lineIndex].columns[0].control),
                                      validation : extractFormlyValidation(configurationModel.lines[lineIndex].columns[0].control)                                  
                                };
        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[0].control.type === 'datepicker') {
          AddDatepickerPopupProperty(controlCol0, configurationModel,lineIndex);
        }                            


        var controlCol1 =  {
                                  className: 'col-xs-6',
                                  type: typeof configurationModel.lines[lineIndex].columns[1].control.type !== 'undefined' ?  (configurationModel.lines[lineIndex].columns[1].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[1].control.type) : 'blank',
                                  key: typeof configurationModel.lines[lineIndex].columns[1].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[1].control.key : 'blank' + Date.now(),
                                  templateOptions: {
                                      type: extractTemplateOptionType(configurationModel.lines[lineIndex].columns[1].control),
                                      label: extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[1].control),
                                      required : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[1].control),
                                      placeholder : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[1].control),
                                      description : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[1].control),
                                      options : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[1].control)
                                  },
                                      expressionProperties : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[1].control),
                                      validators : extractFormlyValidators(configurationModel.lines[lineIndex].columns[1].control),
                                      validation : extractFormlyValidation(configurationModel.lines[lineIndex].columns[1].control)                                  
                          };

        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[1].control.type === 'datepicker') {
          AddDatepickerPopupProperty(controlCol1, configurationModel,lineIndex);
        }                                

        var FieldGroup = [];

        if (configurationModel.lines[lineIndex].columns[0].control.type === 'header') {
          FieldGroup.push(headerTemplateCol0);
        }else{
          FieldGroup.push(controlCol0);
        }
         
        if (configurationModel.lines[lineIndex].columns[1].control.type === 'header') {
          FieldGroup.push(headerTemplateCol1);
        }else{
          FieldGroup.push(controlCol1);
        }    



        formlyModel.push(
                           {
                              className: 'row', 
                              fieldGroup: FieldGroup
                            }
                        );
    }

    function AddThreeColumnControl(formlyModel, configurationModel,lineIndex){

        //text header is stored in "description" in templateOtion model
        var headerTemplateCol0 =  {
                                    className: 'col-xs-4',
                                    template : '<div class="row"><div class=""><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control) + '<h2><hr/></div></div>'
                                  };

        var headerTemplateCol1 =  {
                                    className: 'col-xs-4',
                                   template:'<div class="row"><div class=""><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[1].control) + '<h2><hr/></div></div>'
                                  };

        var headerTemplateCol2 =  {
                                    className: 'col-xs-4',
                                   template:'<div class="row"><div class=""><h2 class="text-center">' + extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[2].control) + '<h2><hr/></div></div>'
                                  };
      

        var controlCol0 =     {
                                  className: 'col-xs-4',
                                  type: typeof configurationModel.lines[lineIndex].columns[0].control.type !== 'undefined' ? (configurationModel.lines[lineIndex].columns[0].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[0].control.type): 'blank',
                                  key: typeof configurationModel.lines[lineIndex].columns[0].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[0].control.key : 'blank' + Date.now(),
                                  templateOptions: {
                                      type: extractTemplateOptionType(configurationModel.lines[lineIndex].columns[0].control),
                                      label: extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[0].control),
                                      required : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[0].control),
                                      placeholder : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[0].control),
                                      description : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[0].control),
                                      options : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[0].control)                                              
                                  },
                                      expressionProperties : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[0].control),
                                      validators : extractFormlyValidators(configurationModel.lines[lineIndex].columns[0].control),
                                      validation : extractFormlyValidation(configurationModel.lines[lineIndex].columns[0].control)                                   
                                };
        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[0].control.type === 'datepicker') {
          AddDatepickerPopupProperty(controlCol0, configurationModel,lineIndex);
        }                             

        var controlCol1 =  {
                                  className: 'col-xs-4',
                                  type: typeof configurationModel.lines[lineIndex].columns[1].control.type !== 'undefined' ?  (configurationModel.lines[lineIndex].columns[1].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[1].control.type) : 'blank',
                                  key: typeof configurationModel.lines[lineIndex].columns[1].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[1].control.key : 'blank' + Date.now(),
                                  templateOptions: {
                                      type: extractTemplateOptionType(configurationModel.lines[lineIndex].columns[1].control),
                                      label: extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[1].control),
                                      required : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[1].control),
                                      placeholder : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[1].control),
                                      description : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[1].control),
                                      options : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[1].control)                                               
                                  },
                                      expressionProperties : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[1].control),
                                      validators : extractFormlyValidators(configurationModel.lines[lineIndex].columns[1].control),
                                      validation : extractFormlyValidation(configurationModel.lines[lineIndex].columns[1].control)                                  
                          };
        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[1].control.type === 'datepicker') {
          AddDatepickerPopupProperty(controlCol1, configurationModel,lineIndex);
        }                       
        var controlCol2 =  {
                                  className: 'col-xs-4',
                                  type: typeof configurationModel.lines[lineIndex].columns[2].control.type !== 'undefined' ?  (configurationModel.lines[lineIndex].columns[2].control.type === 'none' ? 'blank': configurationModel.lines[lineIndex].columns[2].control.type) : 'blank',
                                  key: typeof configurationModel.lines[lineIndex].columns[2].control.key !== 'undefined' ?  configurationModel.lines[lineIndex].columns[2].control.key : 'blank' + Date.now(),
                                  templateOptions: {
                                      type: extractTemplateOptionType(configurationModel.lines[lineIndex].columns[2].control),
                                      label: extractTemplateOptionLabel(configurationModel.lines[lineIndex].columns[2].control),
                                      required : extractTemplateOptionRequired(configurationModel.lines[lineIndex].columns[2].control),
                                      placeholder : extractTemplateOptionPlaceholder(configurationModel.lines[lineIndex].columns[2].control),
                                      description : extractTemplateOptionDescription(configurationModel.lines[lineIndex].columns[2].control),
                                      options : extractTemplateOptionOptions(configurationModel.lines[lineIndex].columns[2].control)                                              
                                  },
                                      expressionProperties : extractFormlyExpressionProperties(configurationModel.lines[lineIndex].columns[2].control),
                                      validators : extractFormlyValidators(configurationModel.lines[lineIndex].columns[2].control),
                                      validation : extractFormlyValidation(configurationModel.lines[lineIndex].columns[2].control)                                   
                          };
        //////////////////////////////////////////////                  
        //datepicker additionnal particular property  
        //////////////////////////////////////////////                  
        if (configurationModel.lines[lineIndex].columns[2].control.type === 'datepicker') {
          AddDatepickerPopupProperty(controlCol2, configurationModel,lineIndex);
        }     

        var FieldGroup = [];

        if (configurationModel.lines[lineIndex].columns[0].control.type === 'header') {
          FieldGroup.push(headerTemplateCol0);
        }else{
          FieldGroup.push(controlCol0);
        }
         
        if (configurationModel.lines[lineIndex].columns[1].control.type === 'header') {
          FieldGroup.push(headerTemplateCol1);
        }else{
          FieldGroup.push(controlCol1);
        }    

        if (configurationModel.lines[lineIndex].columns[2].control.type === 'header') {
          FieldGroup.push(headerTemplateCol2);
        }else{
          FieldGroup.push(controlCol2);
        }    


        formlyModel.push(
                           {
                              className: 'row', 
                              fieldGroup: FieldGroup
                            }
                        );
    }


    function isTemplateOptionDefined(obj){

      return typeof obj.templateOptions !== 'undefined' ? true : false;
    }

    function extractTemplateOptionLabel(obj){

     return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.label !== 'undefined'? obj.templateOptions.label: '') : '';
    }


    function extractTemplateOptionDatepickerPopup(obj){

      return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.datepickerPopup !== 'undefined'? obj.templateOptions.datepickerPopup: '') : '';
    }

    function extractFormlyExpressionProperties(obj){

      return  typeof obj.formlyExpressionProperties !== 'undefined' ? angular.copy(obj.formlyExpressionProperties) : {};
    }

    function extractFormlyValidators(obj){

      return  typeof obj.formlyValidators !== 'undefined' ? angular.copy(obj.formlyValidators): {};
    }

    function extractFormlyValidation(obj){

      return  typeof obj.formlyValidation !== 'undefined' ?  angular.copy(obj.formlyValidation) : {};
    }


    function extractTemplateOptionRequired(obj){

      return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.required !== 'undefined'? obj.templateOptions.required: '') : '';
    }

    function extractTemplateOptionOptions(obj){

      return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.options !== 'undefined'? obj.templateOptions.options: '') : '';
    }

    function extractTemplateOptionType(obj){

      return  typeof obj.subtype !== 'undefined'? obj.subtype: '';
    }

    function extractTemplateOptionPlaceholder(obj){

      return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.placeholder !== 'undefined'? obj.templateOptions.placeholder: '') : '';
    }

    function extractTemplateOptionDescription(obj){

      return  typeof obj.templateOptions !== 'undefined' ? (typeof obj.templateOptions.description !== 'undefined'? obj.templateOptions.description: '') : '';
    }


    function resetDataModel(obj){
      var emptyDataModel = {};
      angular.copy(emptyDataModel, obj);
      return true;
    }

    var messageObj = {
      noError : false,
      title: '',
      Message: ''  
    };

    function getErrorObject(errorTitle, errorMessage){

      var messageObj = {
        noError : false,
        title: '',
        Message: ''  
      };

      messageObj.noError = false;
      messageObj.title = errorTitle;
      messageObj.Message = errorMessage;
      return messageObj;
    }

    function getMessageObject(messageTitle, messageBody){
      var messageObj = {
        noError : false,
        title: '',
        Message: ''  
      };

      messageObj.noError = true;
      messageObj.title = messageTitle;
      messageObj.Message = messageBody;
      return messageObj;
    }
  
}]);






/**
 *  ------------------------------------------------------
 *  service to manage select options (used in modal to edit control)
 *  ------------------------------------------------------
 *
 *  module = "service"  selectOptionManage (manage : selects, radio...)
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

;(function() {
  'use strict';


  angular
    .module('ngwfApp.services.selectOptionManage', [])
    .factory('selectOptionManage', selectOptionManage);

    selectOptionManage.$inject = [];
    function selectOptionManage(){
      var service = {
        testMe                    : testMe,
        initModel                 : initModel,
        isOptionUnique            : isOptionUnique,
        isOptionValidFormat       : isOptionValidFormat,
        addNewOptionRadio         : addNewOptionRadio,
        addNewOptionBasicSelect   : addNewOptionBasicSelect,
        addNewOptionGroupedSelect : addNewOptionGroupedSelect,
        removeOption              : removeOption,
        upthisOption              : upthisOption,
        downthisOption            : downthisOption,
      };
      return service;

      /**
       * just a test function
       */
      function testMe(){
        return 'selectOptionManage is here.';
      }
      /**
       * reset model
       */
      function initModel(selectObj){
        resetModel(selectObj);
      }

      function isOptionUnique(selectObj, textValue){
        for (var i = selectObj.rows.length - 1; i >= 0; i--) {
          if (selectObj.rows[i].option === textValue) return false;
        }
        return true;
      }

      function isOptionValidFormat(textValue){
        if (textValue !== '')  return true;
        return false;
      }

      function addNewOptionRadio(selectObj, newOptionText){
        var fullResponse = {
                              resultFlag : false,
                              details : ''
                            };

        var checkResult = validOption(selectObj, newOptionText);  
        if (checkResult.resultFlag === true){

            var newOption = {
                                option: newOptionText,
                                order: selectObj.rows.length
                            };

            selectObj.rows.push(newOption);
            fullResponse.resultFlag = true;
            fullResponse.details = '';
            return fullResponse;
        }else{
              angular.copy(checkResult, fullResponse);                    
              return fullResponse;                        
        }
      }

      function addNewOptionBasicSelect(selectObj, newOptionText){
          var fullResponse = {
                                resultFlag : false,
                                details : ''
                              };

          var checkResult = validOption(selectObj, newOptionText);  
          if (checkResult.resultFlag === true){

              var newOption = {
                                  option: newOptionText,
                                  order: selectObj.rows.length
                              };

              selectObj.rows.push(newOption);
              fullResponse.resultFlag = true;
              fullResponse.details = '';
              return fullResponse;
          }else{
                angular.copy(checkResult, fullResponse);                    
                return fullResponse;                        
          }
      }

      function addNewOptionGroupedSelect(selectObj, newOptionText, newOptionGroup){
        var fullResponse = {
                              resultFlag : false,
                              details : ''
                            };

        var checkResult = validOption(selectObj, newOptionText);  
    
        if (checkResult.resultFlag === true){

            var newOption = {
                                option: newOptionText,
                                group: newOptionGroup,
                                order: selectObj.rows.length
                            };

            selectObj.rows.push(newOption);
            fullResponse.resultFlag = true;
            fullResponse.details = '';
            return fullResponse;
        }else{
              angular.copy(checkResult, fullResponse);                    
              return fullResponse;                        
        }
      }

      function removeOption(selectObj, AtIndex) {
        var fullResponse = {
                            resultFlag : false,
                            details : ''
                          };

        if (AtIndex !== -1) {
            selectObj.rows.splice(AtIndex, 1);
            fullResponse.resultFlag = true;
            fullResponse.details= '';
            return fullResponse;
        }else{
            fullResponse.resultFlag = false;
            fullResponse.details= 'Option index not valid';
            return fullResponse;
        }
      }

      function upthisOption(selectObj, indexOption){
          var fullResponse = {
                              resultFlag : false,
                              details : ''
                            };  

          if (indexOption > -1) {
            if (indexOption > 0) {
              if (selectObj.rows[indexOption - 1]) {
                var currentOption = selectObj.rows[indexOption];
                selectObj.rows.splice(indexOption , 1);
                selectObj.rows.splice((indexOption - 1), 0, currentOption); 
                fullResponse.resultFlag = true;
                fullResponse.details = '';
                return fullResponse;
              }else{
                fullResponse.resultFlag = false;
                fullResponse.details = 'Can\'t retreive option from option index';
                return fullResponse;
              }
            }else{
                fullResponse.resultFlag = true;
                fullResponse.details = '';
                return fullResponse;
            }  
          }else{
            fullResponse.resultFlag = false;
            fullResponse.details = 'Option index not valid';
            return fullResponse;
          }
      }

      function downthisOption(selectObj, indexOption){
          var fullResponse = {
                              resultFlag : false,
                              details : ''
                            };

          if (indexOption > -1) {
            if (indexOption < selectObj.rows.length - 1){
              if (selectObj.rows[indexOption + 1]) {
                var currentOption = selectObj.rows[indexOption];
                selectObj.rows.splice(indexOption , 1);
                selectObj.rows.splice((indexOption + 1), 0, currentOption);  
                fullResponse.resultFlag = true;
                fullResponse.details = '';
                return fullResponse;  
              }else{
                fullResponse.resultFlag = false;
                fullResponse.details = 'Can\'t retreive option from option index';
                return fullResponse;
              }
            }else{ 
                fullResponse.resultFlag = true;
                fullResponse.details = '';
              return fullResponse;
            }
          }else{
            fullResponse.resultFlag = false;
            fullResponse.details = 'Option index not valid';
            return fullResponse;
          }
      }






      function validOption(selectObj, newOptionText){
          var fullResponse = {
                                resultFlag  : false,
                                details     : ''
                              };

          if (typeof newOptionText === 'undefined') {
              fullResponse.resultFlag = false;
              fullResponse.details    = 'Entered option is empty';
              return fullResponse;
          }

          if (newOptionText !== '') {
                for (var i = selectObj.rows.length - 1; i >= 0; i--) {
                  if (selectObj.rows[i].option === newOptionText) {
                    fullResponse.resultFlag = false;
                    fullResponse.details    = 'Entered option is not unique';
                    return fullResponse;
                  }
                }
                fullResponse.resultFlag = true;
                fullResponse.details    = '';
                return fullResponse;
          }
          fullResponse.resultFlag = false;     
          fullResponse.details    = 'Entered option is empty';
          return fullResponse;
      }

      function resetModel(selectObj){
        var zeroModel = { rows:[] };
        angular.copy(zeroModel, selectObj);
      }
  }


})(); 

    //}


    // .factory('selectOptionManage', [ function(){
    

    //   return {
              // testMe: function() {
              //     return 'selectOptionManage is here.';
              // },

              // initModel: function(selectObj){
              //   resetModel(selectObj);
              // },
          
              // isOptionUnique: function(selectObj, textValue){
              //   for (var i = selectObj.rows.length - 1; i >= 0; i--) {

              //     if (selectObj.rows[i].option === textValue) {
              //       return false;
              //     }
                  
              //   }
              //   return true;
              // },

              //test if not empty string (= full space string is not conidered as valid)
              // isOptionValidFormat: function(textValue){
              //   if (textValue !== '') {
              //     return true;
              //   }
              //   return false;                    
              // },

              // addNewOptionRadio: function(selectObj, newOptionText){
              //   var fullResponse = {
              //                         resultFlag : false,
              //                         details : ''
              //                       };

              //   var checkResult = validOption(selectObj, newOptionText);  

              //   //console.info(checkResult);

              //   if (checkResult.resultFlag === true){

              //       var newOption = {
              //                           option: newOptionText,
              //                           order: selectObj.rows.length
              //                       };

              //       selectObj.rows.push(newOption);
              //       fullResponse.resultFlag = true;
              //       fullResponse.details = "";
              //       return fullResponse;
              //   }else{

              //         angular.copy(checkResult, fullResponse);                    
              //         return fullResponse;                        
              //   }


              // },


              // addNewOptionBasicSelect: function(selectObj, newOptionText){
              //   var fullResponse = {
              //                         resultFlag : false,
              //                         details : ''
              //                       };

              //   var checkResult = validOption(selectObj, newOptionText);  

              //   //console.info(checkResult);

              //   if (checkResult.resultFlag === true){

              //       var newOption = {
              //                           option: newOptionText,
              //                           order: selectObj.rows.length
              //                       };

              //       selectObj.rows.push(newOption);
              //       fullResponse.resultFlag = true;
              //       fullResponse.details = '';
              //       return fullResponse;
              //   }else{

              //         angular.copy(checkResult, fullResponse);                    
              //         return fullResponse;                        
              //   }


              // },

              // addNewOptionGroupedSelect: function(selectObj, newOptionText, newOptionGroup){
              //   var fullResponse = {
              //                         resultFlag : false,
              //                         details : ''
              //                       };

              //   // if (typeof newOptionGroup === "undefined") {

              //   //     fullResponse.resultFlag = false;
              //   //     fullResponse.details = "Group option is undefined";
              //   //     return fullResponse;
              //   // }

              //   // if (newOptionGroup === "") {

              //   //     fullResponse.resultFlag = false;
              //   //     fullResponse.details = "Group option is undefined";
              //   //     return fullResponse;
              //   // }

              //   var checkResult = validOption(selectObj, newOptionText);  

            
              //   if (checkResult.resultFlag === true){

              //       var newOption = {
              //                           option: newOptionText,
              //                           group: newOptionGroup,
              //                           order: selectObj.rows.length
              //                       };

              //       selectObj.rows.push(newOption);
              //       fullResponse.resultFlag = true;
              //       fullResponse.details = '';
              //       return fullResponse;
              //   }else{

              //         angular.copy(checkResult, fullResponse);                    
              //         return fullResponse;                        
              //   }

              // },


              // removeOption:  function(selectObj, AtIndex) {
              //   var fullResponse = {
              //                       resultFlag : false,
              //                       details : ''
              //                     };

              //   if (AtIndex !== -1) {
              //       selectObj.rows.splice(AtIndex, 1);
              //       fullResponse.resultFlag = true;
              //       fullResponse.details= '';
              //       return fullResponse;
              //   }else{
              //       fullResponse.resultFlag = false;
              //       fullResponse.details= 'Option index not valid';
              //       return fullResponse;
              //   }
              // },

            //   upthisOption : function(selectObj, indexOption){
            //     var fullResponse = {
            //                         resultFlag : false,
            //                         details : ''
            //                       };  

            //     if (indexOption > -1) {

            //       if (indexOption > 0) {

            //         if (selectObj.rows[indexOption - 1]) {
            //           var currentOption = selectObj.rows[indexOption];
            //           selectObj.rows.splice(indexOption , 1);
            //           selectObj.rows.splice((indexOption - 1), 0, currentOption); 

            //           fullResponse.resultFlag = true;
            //           fullResponse.details = '';
            //           return fullResponse;
            //         }else{
            //           fullResponse.resultFlag = false;
            //           fullResponse.details = 'Can\'t retreive option from option index';
            //           return fullResponse;
            //         }
            //       }else{
            //           fullResponse.resultFlag = true;
            //           fullResponse.details = '';
            //           return fullResponse;
            //       }  

            //     }else{
            //       fullResponse.resultFlag = false;
            //       fullResponse.details = 'Option index not valid';
            //       return fullResponse;
            //     }
            // },

            // downthisOption : function(selectObj, indexOption){
            //     var fullResponse = {
            //                         resultFlag : false,
            //                         details : ''
            //                       };

            //     if (indexOption > -1) {
    

            //       if (indexOption < selectObj.rows.length - 1){
                    

            //         if (selectObj.rows[indexOption + 1]) {
                      

            //           var currentOption = selectObj.rows[indexOption];
                      
            //           selectObj.rows.splice(indexOption , 1);
            //           selectObj.rows.splice((indexOption + 1), 0, currentOption);  

            //           fullResponse.resultFlag = true;
            //           fullResponse.details = '';
            //           return fullResponse;  

            //         }else{
            //           fullResponse.resultFlag = false;
            //           fullResponse.details = 'Can\'t retreive option from option index';
            //           return fullResponse;
            //         }
            //       }else{

                    
            //           fullResponse.resultFlag = true;
            //           fullResponse.details = '';
            //         return fullResponse;
            //       }


            //     }else{
            //       fullResponse.resultFlag = false;
            //       fullResponse.details = 'Option index not valid';
            //       return fullResponse;
            //     }

            // }

        



  //         };




  // function validOption(selectObj, newOptionText){
  //     var fullResponse = {
  //                           resultFlag : false,
  //                           details : ""
  //                         };

  //     if (typeof newOptionText === 'undefined') {
  //         fullResponse.resultFlag = false;
  //         fullResponse.details = 'Entered option is empty';
  //         return fullResponse;
  //     }

  //     if (newOptionText !== '') {
  //           for (var i = selectObj.rows.length - 1; i >= 0; i--) {
  //             if (selectObj.rows[i].option === newOptionText) {
  //               fullResponse.resultFlag = false;
  //               fullResponse.details = 'Entered option is not unique';
  //               return fullResponse;
  //             }
  //           }
  //           fullResponse.resultFlag = true;
  //           fullResponse.details = '';
  //           return fullResponse;
  //     }
  //     fullResponse.resultFlag = false;     
  //     fullResponse.details = 'Entered option is empty';
  //     return fullResponse;
  // }

  // function resetModel(selectObj){
  //   var zeroModel = { 
  //                       rows:
  //                       [
  //                       ]
  //                     };

    
  //   angular.copy(zeroModel, selectObj);
  // }

  

  // }]);









/**
 *  ------------------------------------------------------
 *  module = "services" container
 *  ------------------------------------------------------
 *
 * contains all app services
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

;(function () {
	'use strict';

	angular.module(
									'ngwfApp.services', [	
																				'ngwfApp.services.formFieldManage',
																				'ngwfApp.services.selectOptionManage',
																				'ngwfApp.services.ngwfWfFormsServices',
																				'ngwfApp.services.ngwfEditCtrlControllerModalProxy'
																			]
								);

})(); 


/**
 *  ------------------------------------------------------
 *  form API : suppose you have your RESTful backend 
 *  ------------------------------------------------------
 *
 *  
 *
 * ——————————————————————————————————————————————
 * MIT (2015) - Erwan Datin (MacKentoch)
 * https://github.com/MacKentoch/easyFormGenerator
 * ——————————————————————————————————————————————
**/

(function(){

	'use strict';
	
	angular
		.module('ngwfApp.services.ngwfWfFormsServices', ['ngResource'])
		.factory('wfFormsByIdServices', wfFormsByIdServices);

		wfFormsByIdServices.$inject = ['$resource'];
		function wfFormsByIdServices($resource){
			return $resource('/api/wfedit/:id', {id: '@id'}, {});
		}


})();
})(this);